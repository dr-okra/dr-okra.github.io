
<html>
	<head>
		<title>Lerp</title>
		<style>
			body { margin: 0; 
				background: #000; 
				color: #fff;
        font-family: monospace;
			}
			canvas { width: 100%; height: 100% }
			button { background: transparent; border:none; outline:none; cursor: pointer; font-family: monospace; font-size: 4em; color: #fff;}
			#hud {position: absolute; top:0px; left:0px; width: 110px; }
			#go {left: 1em; display: none;}
			#go.show {left: 1em; display: block;}
			button.on {color: red;}

			.slidecontainer {
        /*width: 90%;*/
       transform: rotate(-90deg);
       width: 300px; 
       height: 300px;
         display: block; margin: 20px auto; padding:10px;
       }
			#rotate {font-size: 1em; position: fixed; bottom:20px; right: 20px;}

.slider {
  -webkit-appearance: none;
  width: 100%;
  height: 2px;
  background: rgba(200,200,200,0.2);
  outline: none;
  -webkit-transition: .2s;
  transition: opacity .2s;
}

.slidecontainer{
  margin: 40px;
}

.slider::-webkit-slider-thumb {
  -webkit-appearance: none;
  appearance: none;
  width: 50px;
  height: 50px;
  border: 0;
  background: red;
  background-size: 70px;
  cursor: pointer;
  border-radius: 50%;
}

.slider::-moz-range-thumb {
  width: 50px;
  height: 50px;
  border: 0;
  background: red;
  background-size: 70px;
  cursor: pointer;
  border-radius: 50%;
}

.note {position: absolute; right: 20px;}
		</style>
	</head>
	<body>
	
<div id="hud">
<div class="slidecontainer">
  <input class="slider" id="carrier" type="range" value="0" min="0" max="0.0055" step="0.00001" oninput="handleCarrierChange(value)" />
</div>
</div>


<script src="../js/three.min.js"></script>
<script src="../js/GLTFLoader.js"></script>
<script src="../js/OrbitControls.min.js"></script>
<script src="../js/tween.js"></script>


<script>
var stopwarp = true;

var xval = 0;
var mixer;
var prevTime = Date.now();
var scene = new THREE.Scene();
var camera = new THREE.PerspectiveCamera( 75, window.innerWidth/window.innerHeight, 0.8, 1000 );
var renderer = new THREE.WebGLRenderer( { alpha: true, antialias: true } );
renderer.setSize( window.innerWidth, window.innerHeight );
// renderer.localClippingEnabled = true;
renderer.shadowMap.enabled = true;
renderer.shadowMap.type = THREE.PCFShadowMap;
document.body.appendChild( renderer.domElement );
        // container = document.createElement( 'div' );
        // document.body.appendChild( container );
        // container.appendChild( renderer.domElement );

scene.position.set(0,-1,0);

// lights
var light = new THREE.PointLight( 0xffffff, 1, 40 );
light.position.set( 10, 10, 10 );
scene.add( light );

camera.position.x = 6;
camera.position.y = 1;
camera.position.z = 0;
camera.lookAt(0,0,0)

var controls = new THREE.OrbitControls(camera, renderer.domElement);
controls.maxPolarAngle = Math.PI*0.51;
controls.enableDamping = true;
controls.dampingFactor = 0.4;
controls.maxDistance = 250;
controls.minDistance = 4;
controls.enablePan = false;

// grid
var size = 10;
var divisions = 1;
var gridHelper = new THREE.GridHelper( size, divisions );
gridHelper.position.set( 0, 0.1, 0 );
// gridHelper.scale.set(50,1,1);
// scene.add( gridHelper );

//spider light
// var splight = new THREE.SpotLight( 0xffffff, 0.1 );
// splight.position.set( 0, 650, 0 );
// splight.castShadow = true;
// splight.shadow = new THREE.LightShadow( new THREE.PerspectiveCamera( 6, 1, 200, 1000 ) );
// splight.shadow.mapSize.width = 256;
// splight.shadow.mapSize.height = 256;
// splight.name = 'splight';
// scene.add( splight );

// ambient
var light = new THREE.AmbientLight( 0x666666 );
light.intensity = 0.9;
scene.add( light );



// floor texture
// var geometry =  new THREE.CircleBufferGeometry( 7, 30 );
var geometry = new THREE.PlaneBufferGeometry( 10, 10, 1 );

var material = new THREE.MeshLambertMaterial( {color: 0x333333} );
var ground = new THREE.Mesh( geometry, material );
// ground.receiveShadow = true;
ground.rotation.set (-Math.PI/2,0,0);
scene.add( ground );


// shadowground
var txloader = new THREE.TextureLoader();
var groundtex = txloader.load( 'tex.png' );
groundtex.magFilter = THREE.NearestFilter;
groundtex.minFilter = THREE.LinearMipMapLinearFilter;
groundtex.wrapS = groundtex.wrapT = THREE.RepeatWrapping;
var material = new THREE.MeshBasicMaterial( {color: 0xffffff
,transparent : true, opacity:0.9
,map:groundtex 
} );
var shadowground = new THREE.Mesh( geometry, material );
shadowground.position.set (0,0.05,0);
shadowground.scale.set (1.1,1.1,1.1);
shadowground.rotation.set (-Math.PI/2,0,0);
scene.add( shadowground );



// resize
window.addEventListener( 'resize', onWindowResize, false );
function onWindowResize() {
camera.aspect = window.innerWidth / window.innerHeight;
camera.updateProjectionMatrix();
renderer.setSize( window.innerWidth, window.innerHeight );
}

// hero
hero = new THREE.Group();
scene.add( hero );

cursor = new THREE.Group();
scene.add(cursor);

mothership = new THREE.Group();
scene.add(mothership);

cube = new THREE.Group();
mothership.add(cube);

// hero
let bgeometry = new THREE.BoxGeometry( 0.6, 0.1, 0.6 );
let mmaterial = new THREE.MeshLambertMaterial( { color: 0xcc0000 } );
let cubicbody = new THREE.Mesh( bgeometry, mmaterial );
cubicbody.position.set(0,0.3,0);
cube.add( cubicbody );

// mothership
// let msgeometry = new THREE.BoxGeometry( 0.8, 0.1, 0.8 );
// let mothership = new THREE.Mesh( msgeometry, mmaterial );
// mothership.position.set(0,0.4,0);
// // mothership.castShadow = true;
// scene.add( mothership );

// disc
// var curve = new THREE.EllipseCurve(
//   0,  0,            // ax, aY
//   0.7, 0.7,           // xRadius, yRadius
//   0,  2 * Math.PI,  // aStartAngle, aEndAngle
//   false,            // aClockwise
//   0                 // aRotation
// );

// var points = curve.getPoints( 60 );
// var dgeometry = new THREE.BufferGeometry().setFromPoints( points );
// var dmaterial = new THREE.LineBasicMaterial( { color : 0x666666
//  } );

// var xellipse = new THREE.Line( dgeometry, dmaterial );
// xellipse.rotation.x = Math.PI/2;
// xellipse.position.y = 0.5;
// hero.add(xellipse);



// disc
// var curve = new THREE.EllipseCurve(
//   0,  0,            // ax, aY
//   0.7, 0.7,           // xRadius, yRadius
//   0,  2 * Math.PI,  // aStartAngle, aEndAngle
//   false,            // aClockwise
//   0                 // aRotation
// );

// var points = curve.getPoints( 60 );
// var dgeometry = new THREE.BufferGeometry().setFromPoints( points );
// var dmaterial = new THREE.LineBasicMaterial( { color : 0x666666
//  } );

// var ellipse = new THREE.Line( dgeometry, dmaterial );
// ellipse.rotation.x = Math.PI/2;
// ellipse.position.y = 0.5;







// // mothership
var loader = new THREE.BufferGeometryLoader();

loader.load(
  'xcar.json',
  function ( geometry ) {
    var material = new THREE.MeshPhongMaterial( { 
          color: 0xffffff
          // , transparent:true, opacity:0.5
       } );


    car = new THREE.Mesh( geometry, material );
    car.name = "car"
    car.position.set(0,0.3, 0);
    car.rotation.set(0,Math.PI/2,0);
    car.scale.set(1,1,1);
    mothership.add( car );

},
  function ( xhr ) {
  },
  function ( xhr ) {
    console.log( 'An error happened' );
  }
  );// end load ship

// shadow 
let egeometry = new THREE.PlaneGeometry( 0.8, 0.8, 1 );
let ematerial = new THREE.MeshBasicMaterial( { color: 0x000000, transparent:true,
opacity:0.2 } );
let shdw = new THREE.Mesh( egeometry, ematerial );
shdw.position.set(0,0.1,0);
shdw.rotation.set(-Math.PI/2,0,0)
mothership.add(shdw);


// var loader = new THREE.TextureLoader();
// var grad = loader.load( 'wgrad.png', true );


// trail
var loader = new THREE.TextureLoader();
loader.load( 'xgrad.png', function ( texture ) {
  var trgeometry = new THREE.PlaneGeometry( 0.1, 0.6, 1 );
  trgeometry.applyMatrix( new THREE.Matrix4().makeTranslation(0.05, 0, 0) );

  var trmaterial = new THREE.MeshBasicMaterial( { map: texture, transparent: true, opacity: 0.3
   } );
  var trail = new THREE.Mesh( trgeometry, trmaterial );
  trail.name = "trail";
  trail.position.set(0.2,0.3,0);
  trail.rotation.set(-Math.PI/2,0,0)
  mothership.add(trail);
} );



// sky night
var loader = new THREE.TextureLoader();
loader.load( 'wgrad.png', function ( texture ) {
  var skygeometry = new THREE.SphereGeometry(501, 32, 32)
  var skymaterial = new THREE.MeshBasicMaterial( { map: texture, side : THREE.BackSide
  ,transparent: true, opacity: 0.8
   } );
  var skyn = new THREE.Mesh( skygeometry, skymaterial );
  skyn.name = "skynight";
  scene.add(skyn);
} );


function handleCarrierChange(value) {
xval = value;
if (value>0) {stopwarp = false; }
}
//

// update touch
  let updateTouchCoordinates = function(evt) {
  stopwarp = false; 
  mouse.x = ( evt.touches[0].pageX / window.innerWidth ) * 2 - 1;
  mouse.y = - ( evt.touches[0].pageY / window.innerHeight ) * 2 + 1;
  raycaster.setFromCamera( mouse, camera );
  let intersects = raycaster.intersectObject( plane );
  if (intersects.length > 0) { movehero(intersects[ 0 ].point.x, intersects[ 0 ].point.z); }
};


// update mouse
let updateMouseCoordinates = function(evt) {
  evt.preventDefault();
  mouse.x = ( evt.clientX / window.innerWidth ) * 2 - 1;
  mouse.y = - ( evt.clientY / window.innerHeight ) * 2 + 1;
  raycaster.setFromCamera( mouse, camera );
  let intersects = raycaster.intersectObject( plane );
  if (intersects.length > 0) { movehero(intersects[ 0 ].point.x, intersects[ 0 ].point.z); }
// check l/r
        // if (evt.pageX < oldx) {
        //     direction = "left"; console.log('l')
        // } else if (evt.pageX > oldx) {
        //     direction = "right"; console.log('r')
        // }
        
        // // document.body.innerHTML = direction;
        
        // oldx = evt.pageX;
};


function movehero(x, y) {
    hero.position.x = x;
    hero.position.z = y;
}


window.addEventListener( 'mousemove', updateMouseCoordinates, false );



//raycaster
let raycaster = new THREE.Raycaster();
let mouse = new THREE.Vector2();
let isDragging = false;

//plane geometry
let plgeometry = new THREE.PlaneBufferGeometry( 10, 10, 10, 10 );

//plane material
let plmaterial = new THREE.MeshBasicMaterial( { 
transparent:true,
opacity:0
} );

//plane object3D
let plane = new THREE.Mesh( plgeometry, plmaterial );
plane.name = 'plane';
plane.rotation.set(-Math.PI/2,0,0);
plane.name = 'plane';
scene.add( plane );

// slow down to stop
function decnum() {
  var sf = scene.getObjectByProperty( 'name', 'starfield', false );

for ( var i = 0; i < sf.children.length; i ++ ) {
new TWEEN.Tween( sf.children[i].scale ).to( {x: 1, y: 1, z: 0.01}, 400 ).start();
}//for
document.getElementById('carrier').value = 0;
xval = document.getElementById('carrier').value;
// new TWEEN.Tween( mothership.scale ).to( {x:1, y:1, z:1}, 200).easing( TWEEN.Easing.Quadratic.EaseOut).start();
var ff = scene.getObjectByProperty( 'name', 'trail', false );
new TWEEN.Tween( ff.scale ).to( {x: 0.1, y: 1, z: 1}, 100 ).start();

stopwarp = true;
};

// accelerate
function incnum() {
  var sf = scene.getObjectByProperty( 'name', 'starfield', false );

  // console.log(scene)
  for ( var i = 0; i < sf.children.length; i ++ ) {
new TWEEN.Tween( sf.children[i].scale ).to( {x: 1, y: 1, z: 1}, 400 ).start();
}//for
document.getElementById('carrier').value = 0.0055;
xval = document.getElementById('carrier').value;

var ff = scene.getObjectByProperty( 'name', 'trail', false );
new TWEEN.Tween( ff.scale ).to( {x: 10, y: 1, z: 1}, 100 ).start();

// new TWEEN.Tween( xval ).to( 0.0055, 200).easing( TWEEN.Easing.Quadratic.EaseOut)
// .onUpdate(function(){document.getElementById('carrier').value=xval}).start();
// new TWEEN.Tween( mothership.scale ).to( {x:1+xval*100, y:1, z:1}, 200).easing( TWEEN.Easing.Quadratic.EaseOut).start();
stopwarp = false;
};

function jump() {
//   new TWEEN.Tween( mothership.position.y ).to( mothership.position.y+1, 200 )
//   .onComplete(function() {
// new TWEEN.Tween( mothership.position.y ).to( 0, 200 ).start();
// }).start();
      console.log(mothership.position.y)

}


//keys
//esc
document.onkeydown = function(evt) {
    evt = evt || window.event;
    // console.log(evt)

if (evt.keyCode == 32) {
  evt.preventDefault();
  jump()
}

if (evt.keyCode == 38) {
  evt.preventDefault();
  incnum()
}

if (evt.keyCode == 40) {
  evt.preventDefault();
  decnum()
}
    
  };



// randomise
function randomFloat(a, b){
  var r =  (Math.random() * (b - a) + a);
  return r;
}

// make single star
function Star(material, x, y, size){
  this.size = size;

  this.obj = new THREE.Geometry();
  this.obj.vertices.push(new THREE.Vector3(0, 0, 0));
  this.obj.vertices.push(new THREE.Vector3(0, 0, -size));
  this.obj = new THREE.Line(this.obj, material);

  this.speed = randomFloat(1, 10);

  this.refresh = function(x, y){
    this.obj.position.z = randomFloat(0, -100);
    this.obj.position.x = x;
    this.obj.position.y = 0.2;
  }
  this.refresh(x, y);
}

// make/update star field
function Starfield(size, width, height){
  this.stars = [];
  this.obj = new THREE.Group();
  this.obj.name = "starfield";
  this.obj.rotation.set(0,Math.PI/2,0);
  this.obj.position.set(0,0,0);
  this.size = size;
  this.width = width;
  this.height = height;
  this.material = new THREE.MeshBasicMaterial({color: 0xffffff});
  this.init = function(){
    for(var i = 0; i < this.size; i++){
      this.stars.push(new Star(this.material, randomFloat(-this.width, this.width), randomFloat(-this.width, this.width), randomFloat(0.1, 3)));
      this.obj.add(this.stars[i].obj);
    }
    scene.add(this.obj);
  }
  this.init();
  this.update = function(){
if (!stopwarp) {
    for(var i = 0; i < this.size; i++){
      if(this.stars[i].obj.position.z > 5){
        this.stars[i].refresh(randomFloat(-this.width, this.width), randomFloat(-this.width, this.width));
      }

      // this.stars[i].obj.position.z += this.stars[i].speed;
      this.stars[i].obj.position.z += xval*80;

          }

      }//if not stopwarp
  }// update
}





// animate loop
var animate = function () {
requestAnimationFrame( animate );
renderer.render(scene, camera);
controls.update();
TWEEN.update();
stars.update();

groundtex.offset.x -= xval*3;
// position lerp
mothership.position.x += (hero.position.x - cursor.position.x)*0.1;
mothership.position.z += (hero.position.z - cursor.position.z)*0.2;
// 
cursor.position.x = mothership.position.x;
cursor.position.z = mothership.position.z;

mothership.rotation.x = (hero.position.z - mothership.position.z)*0.2;// bank
mothership.rotation.z = -(hero.position.x - mothership.position.x)*0.05;// pitch
mothership.rotation.y = (hero.position.z - mothership.position.z)*0.2;// turn


mothership.scale.x = 1+xval*30;
};

  setTimeout(function () {
    /// stars
  stars = new Starfield(10, 7, 1);
    var sf = scene.getObjectByProperty( 'name', 'starfield', false );
for ( var i = 0; i < sf.children.length; i ++ ) { sf.children[i].scale.z = 0.1; }

animate();
  }, 200);

		</script>
	</body>
</html>