
<html>
	<head>
		<title>Hovership</title>
		<style>
			body { margin: 0; 
				background: #333; 
				color: #fff;
        font-family: monospace;
			}
			canvas { width: 100%; height: 100% }
			button { background: transparent; border:none; outline:none; cursor: pointer; font-family: monospace; font-size: 4em; color: #fff;}
			#hud {position: absolute; top:0px; left:0px; width: 110px; }
			#go {left: 1em; display: none;}
			#go.show {left: 1em; display: block;}

			.slidecontainer {
        /*width: 90%;*/
       transform: rotate(-90deg);
       width: 300px; 
       height: 300px;
         display: block; margin: 20px auto; padding:10px;
       }
			#rotate {font-size: 1em; position: fixed; bottom:20px; right: 20px;}

.slider {
  -webkit-appearance: none;
  width: 100%;
  height: 2px;
  background: rgba(200,200,200,0.2);
  outline: none;
  -webkit-transition: .2s;
  transition: opacity .2s;
}

.slidecontainer{
  margin: 40px;
}

.slider::-webkit-slider-thumb {
  -webkit-appearance: none;
  appearance: none;
  width: 50px;
  height: 50px;
  border: 0;
  background: red;
  background-size: 70px;
  cursor: pointer;
  border-radius: 50%;
}

.slider::-moz-range-thumb {
  width: 50px;
  height: 50px;
  border: 0;
  background: red;
  background-size: 70px;
  cursor: pointer;
  border-radius: 50%;
}

.note {position: absolute; right: 20px;}
#vert {position: absolute; top: 12px; right: 12px;
display: block; width: 40px; height: 40px; text-align: center; line-height: 40px; background: red; border-radius: 100%; font-size: 1em;}
button.on {color: red; background: #fff !important;}
.keys {position: absolute; bottom: 12px; left: 12px; opacity: 0.1;}
.keys:hover {opacity: 1;}
		</style>
	</head>
	<body>

		<p class="keys">keys: go:up, stop:down, space:fly/drive</p>

		<button id="vert" title="flip vertical/horizontal mode">+</button>
	
<div id="hud">
<div class="slidecontainer">
  <input class="slider" id="carrier" type="range" value="0" min="0" max="0.0055" step="0.00001" oninput="handleCarrierChange(value)" />
</div>
</div>


<script src="../js/three.min.js"></script>
<script src="../js/GLTFLoader.js"></script>
<script src="../js/OrbitControls.min.js"></script>
<script src="../js/tween.js"></script>


<script>
// slider function
function handleCarrierChange(value) {
xval = value;
if (value>0) {stopwarp = false; 
  var ff = scene.getObjectByProperty( 'name', 'trail', false );
  ff.scale.x = 20*(value*200); } else {
    ff.scale.x = 0;
  }
}

var vertbtn = document.getElementById("vert");
vertbtn.addEventListener("click",verticalview, false );
// vertical mode
function verticalview() {
  vertbtn.classList.toggle('on');
  if (vertbtn.classList != "on") {
plane.rotation.set(-Math.PI/2,0,0);
shadowground.visible = true;
// ground.visible = true;
shdw.visible = true;
// cylinder.visible = false;
horizontal = true;
new TWEEN.Tween( mothership.position).to( {x: mothership.position.x, y: 0, z: mothership.position.z}, 200 ).easing( TWEEN.Easing.Quadratic.EaseOut).start();
new TWEEN.Tween( gridHelper.rotation).to( {x: 0, y: 0, z: 0}, 200 ).easing( TWEEN.Easing.Quadratic.EaseOut).start();

  } else {
plane.rotation.set(0,Math.PI/2,0);
shadowground.visible = false;
// ground.visible = false;
shdw.visible = false;
horizontal = false;
// cylinder.visible = true;
cursor.position.x = 0;
new TWEEN.Tween( gridHelper.rotation).to( {x: 0, y: 0, z: Math.PI/2}, 200 ).easing( TWEEN.Easing.Quadratic.EaseOut).start();

  setTimeout(function() {
new TWEEN.Tween( hero.position).to( {x: 0, y: mothership.position.y, z: mothership.position.z}, 200 ).easing( TWEEN.Easing.Quadratic.EaseOut).start();
// cursor.position.x = 0;
// hero.position.x = 0;
    }, 100);


}

}



var stopwarp = true;
var horizontal = true;

var xval = 0;
var mixer;
var prevTime = Date.now();
var scene = new THREE.Scene();
var camera = new THREE.PerspectiveCamera( 75, window.innerWidth/window.innerHeight, 0.8, 1000 );
var renderer = new THREE.WebGLRenderer( { alpha: true, antialias: true } );
renderer.setSize( window.innerWidth, window.innerHeight );
// renderer.localClippingEnabled = true;
renderer.shadowMap.enabled = true;
renderer.shadowMap.type = THREE.PCFShadowMap;
document.body.appendChild( renderer.domElement );

// scene settings
scene.position.set(0,0,0);
camera.position.x = 6;
camera.position.y = 1;
camera.position.z = 0;
camera.lookAt(0,0,0)

// lights
var light = new THREE.PointLight( 0xffffff, 1, 40 );
light.position.set( 10, 10, 10 );
scene.add( light );


var controls = new THREE.OrbitControls(camera, renderer.domElement);
controls.maxPolarAngle = Math.PI*0.46;
controls.enableDamping = true;
controls.dampingFactor = 0.4;
controls.maxDistance = 50;
controls.minDistance = 6;
controls.enablePan = false;

// grid
var size = 10;
var divisions = 1;
var gridHelper = new THREE.GridHelper( size, divisions );
// gridHelper.position.set( 0, 0.1, 0 );
scene.add(gridHelper)

// ambient
var light = new THREE.AmbientLight( 0x666666 );
light.intensity = 0.9;
scene.add( light );


// floor texture
var geometry = new THREE.PlaneBufferGeometry( 10, 10, 1 );

// var material = new THREE.MeshLambertMaterial( {color: 0x333333} );
// var ground = new THREE.Mesh( geometry, material );
// // ground.receiveShadow = true;
// ground.rotation.set (-Math.PI/2,0,0);
// scene.add( ground );


// shadowground
var txloader = new THREE.TextureLoader();
var groundtex = txloader.load( 'space.png' );
groundtex.magFilter = THREE.NearestFilter;
groundtex.minFilter = THREE.LinearMipMapLinearFilter;
groundtex.wrapS = groundtex.wrapT = THREE.RepeatWrapping;
var material = new THREE.MeshBasicMaterial( {color: 0xffffff
,transparent : true, opacity:0.4
,map:groundtex 
} );
var shadowground = new THREE.Mesh( geometry, material );
shadowground.position.set (0,0.05,0);
// shadowground.scale.set (1,1,1);
shadowground.rotation.set (-Math.PI/2,0,0);
scene.add( shadowground );
// shadowground.visible = false;


// cylinder
// var geometry = new THREE.CylinderBufferGeometry( 50, 50, 200, 60, 1, true
//  );
// var material = new THREE.MeshBasicMaterial( {color: 0xff0000, transparent : true, opacity:0.2,
// map:groundtex, side: THREE.BackSide } );
// var cylinder = new THREE.Mesh( geometry, material );
// cylinder.rotation.set (0,0,-Math.PI/2);
// scene.add( cylinder );
// cylinder.visible = false;


// resize
window.addEventListener( 'resize', onWindowResize, false );
function onWindowResize() {
camera.aspect = window.innerWidth / window.innerHeight;
camera.updateProjectionMatrix();
renderer.setSize( window.innerWidth, window.innerHeight );
}

// hero
hero = new THREE.Group();
scene.add( hero );

cursor = new THREE.Group();
scene.add(cursor);

mothership = new THREE.Group();
scene.add(mothership);

cube = new THREE.Group();
mothership.add(cube);

// hero
let bgeometry = new THREE.BoxGeometry( 0.6, 0.1, 0.6 );
let mmaterial = new THREE.MeshLambertMaterial( { color: 0xcc0000 } );
let cubicbody = new THREE.Mesh( bgeometry, mmaterial );
cubicbody.position.set(0,0.3,0);
// cube.add( cubicbody );



// // car 3D model
var loader = new THREE.BufferGeometryLoader();

loader.load(
  'hcar.json',
  function ( geometry ) {
    var material = new THREE.MeshPhongMaterial( { 
          color: 0xff0000
          // , transparent:true, opacity:0.5
       } );


    car = new THREE.Mesh( geometry, material );
    car.name = "car"
    car.position.set(0,0.3, 0);
    car.rotation.set(0,Math.PI/2,0);
    car.scale.set(0.4,0.4,0.4);
    mothership.add( car );

},
  function ( xhr ) {
  },
  function ( xhr ) {
    console.log( 'An error happened' );
  }
  );// end load ship

// shadow 
let egeometry = new THREE.PlaneGeometry( 1.5, 0.6, 1 );
let ematerial = new THREE.MeshBasicMaterial( { color: 0x000000, transparent:true,
opacity:0.2 } );
let shdw = new THREE.Mesh( egeometry, ematerial );
shdw.position.set(0,0.2,0);
shdw.rotation.set(-Math.PI/2,0,0)
mothership.add(shdw);


// trail
var loader = new THREE.TextureLoader();
loader.load( 'xgrad.png', function ( texture ) {
  var trgeometry = new THREE.PlaneBufferGeometry( 0.1, 0.6, 1 );
  trgeometry.applyMatrix( new THREE.Matrix4().makeTranslation(0.05, 0, 0) );

  var trmaterial = new THREE.MeshBasicMaterial( {
  color:0xff0000, map: texture, transparent: true, opacity: 0.7, side: THREE.DoubleSide
   } );
  var trail = new THREE.Mesh( trgeometry, trmaterial );
  trail.name = "trail";
  trail.position.set(0.2,0.45,0);
  trail.rotation.set(-Math.PI/2,0,0)
  mothership.add(trail);
//   trail.geometry.verticesNeedUpdate=true;
// console.log(trail.geometry)
  // trail.geometry.vertices[1].x+=.01;
} );



// sky night
var loader = new THREE.TextureLoader();
loader.load( 'wgrad.png', function ( texture ) {
  var skygeometry = new THREE.SphereGeometry(501, 32, 32)
  var skymaterial = new THREE.MeshBasicMaterial( { map: texture, side : THREE.BackSide
  ,transparent: true, opacity: 0.8
   } );
  var skyn = new THREE.Mesh( skygeometry, skymaterial );
  skyn.name = "skynight";
  scene.add(skyn);
} );


// end three objects

// update touch
  let updateTouchCoordinates = function(evt) {
  stopwarp = false; 
  mouse.x = ( evt.touches[0].pageX / window.innerWidth ) * 2 - 1;
  mouse.y = - ( evt.touches[0].pageY / window.innerHeight ) * 2 + 1;
  raycaster.setFromCamera( mouse, camera );
  let intersects = raycaster.intersectObject( plane );
  if (intersects.length > 0) { movehero(intersects[ 0 ].point.x, intersects[ 0 ].point.z); }
};


// update mouse
let updateMouseCoordinates = function(evt) {
  evt.preventDefault();
  mouse.x = ( evt.clientX / window.innerWidth ) * 2 - 1;
  mouse.y = - ( evt.clientY / window.innerHeight ) * 2 + 1;
  raycaster.setFromCamera( mouse, camera );
  let intersects = raycaster.intersectObject( plane );
  if (intersects.length > 0) { movehero(intersects[ 0 ].point.x, intersects[ 0 ].point.z, intersects[ 0 ].point.y); }

};


function movehero(x, y, z) {
    hero.position.x = x;
    hero.position.z = y;
    hero.position.y = z;
}


window.addEventListener( 'mousemove', updateMouseCoordinates, false );



//raycaster
let raycaster = new THREE.Raycaster();
let mouse = new THREE.Vector2();
let isDragging = false;

//plane geometry
let plgeometry = new THREE.PlaneBufferGeometry( 10, 10, 1 );

//plane material
let plmaterial = new THREE.MeshBasicMaterial( { 
// color:0x220000,
side: THREE.DoubleSide,
wireframe: true,
transparent:true,
opacity:0
} );

//raycast plane object3D
let plane = new THREE.Mesh( plgeometry, plmaterial );
plane.name = 'plane';
plane.rotation.set(-Math.PI/2,0,0);
plane.name = 'plane';
scene.add( plane );
// plane.visible = false;

// slow down to stop
function decnum() {
  var sf = scene.getObjectByProperty( 'name', 'starfield', false );

for ( var i = 0; i < sf.children.length; i ++ ) {
new TWEEN.Tween( sf.children[i].scale ).to( {x: 1, y: 1, z: 0.01}, 400 ).start();
}//for
document.getElementById('carrier').value = 0;
xval = document.getElementById('carrier').value;


var ff = scene.getObjectByProperty( 'name', 'trail', false );
new TWEEN.Tween( ff.scale ).to( {x: 0.1, y: 1, z: 1}, 200 ).start();

stopwarp = true;
};

// accelerate
function incnum() {
  var sf = scene.getObjectByProperty( 'name', 'starfield', false );

  // console.log(scene)
  for ( var i = 0; i < sf.children.length; i ++ ) {
new TWEEN.Tween( sf.children[i].scale ).to( {x: 1, y: 1, z: 1}, 400 ).start();
}//for
document.getElementById('carrier').value = 0.0055;
xval = document.getElementById('carrier').value;

var ff = scene.getObjectByProperty( 'name', 'trail', false );
new TWEEN.Tween( ff.scale ).to( {x: 20, y: 1, z: 1}, 200 ).start();

stopwarp = false;
};

function jump() {
      console.log(mothership.position.y)
}


//keys
//esc
document.onkeydown = function(evt) {
    evt = evt || window.event;
    // console.log(evt)

if (evt.keyCode == 32) {
  evt.preventDefault();
  verticalview()
}

if (evt.keyCode == 38) {
  evt.preventDefault();
  incnum()
}

if (evt.keyCode == 40) {
  evt.preventDefault();
  decnum()
}
    
  };



// randomise
function randomFloat(a, b){
  var r =  (Math.random() * (b - a) + a);
  return r;
}

// make single star
function Star(material, x, y, size){
  this.size = size;

  this.obj = new THREE.Geometry();
  this.obj.vertices.push(new THREE.Vector3(0, 0, 0));
  this.obj.vertices.push(new THREE.Vector3(0, 0, -size));
  this.obj = new THREE.Line(this.obj, material);

  this.speed = randomFloat(1, 10);

  this.refresh = function(x, y){
    this.obj.position.z = randomFloat(0, -100);
    this.obj.position.x = x;
    this.obj.position.y = y;
  }
  this.refresh(x, y);
}

// make/update star field
function Starfield(size, width, height){
  this.stars = [];
  this.obj = new THREE.Group();
  this.obj.name = "starfield";
  this.obj.rotation.set(0,Math.PI/2,0);
  this.obj.position.set(0,0,0);
  this.size = size;
  this.width = width;
  this.height = height;
  this.material = new THREE.MeshBasicMaterial({color: 0xffffff});
  this.init = function(){
    for(var i = 0; i < this.size; i++){
      this.stars.push(new Star(this.material, randomFloat(-this.width, this.width), randomFloat(-this.width, this.width), randomFloat(0.1, 3)));
      this.obj.add(this.stars[i].obj);
    }
    scene.add(this.obj);
  }
  this.init();
  this.update = function(){
if (!stopwarp) {
    for(var i = 0; i < this.size; i++){
      if(this.stars[i].obj.position.z > 5){
        this.stars[i].refresh(randomFloat(-this.width, this.width), randomFloat(-this.width, this.width));
      }

      // this.stars[i].obj.position.z += this.stars[i].speed;
      this.stars[i].obj.position.z += xval*80;

          }

      }//if not stopwarp
  }// update
}





// animate loop
var animate = function () {
requestAnimationFrame( animate );
renderer.render(scene, camera);
controls.update();
TWEEN.update();
stars.update();


groundtex.offset.x -= xval*3;
// position lerp
mothership.position.x += (hero.position.x - cursor.position.x)*0.1;
mothership.position.z += (hero.position.z - cursor.position.z)*0.2;
// 
cursor.position.x = mothership.position.x;
cursor.position.z = mothership.position.z;
//
mothership.rotation.x = (hero.position.z - mothership.position.z)*0.2;// bank
mothership.rotation.z = -(hero.position.x - mothership.position.x)*0.05;// pitch
mothership.rotation.y = (hero.position.z - mothership.position.z)*0.2;// turn

// vertical controls
if (!horizontal) { 
mothership.position.y += (hero.position.y - cursor.position.y)*0.5;
cursor.position.y = mothership.position.y;
mothership.rotation.z = -(hero.position.y - mothership.position.y)*0.5;// bank
groundtex.offset.x =0;
groundtex.offset.y -= xval*3;
}
// mothership.scale.x = 1+xval*30;
};

  setTimeout(function () {
    /// stars
  stars = new Starfield(10, 9, 9);
    var sf = scene.getObjectByProperty( 'name', 'starfield', false );
for ( var i = 0; i < sf.children.length; i ++ ) { sf.children[i].scale.z = 0.1; }

animate();
  }, 200);

		</script>
	</body>
</html>
