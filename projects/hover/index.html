
<html>
	<head>
		<title>Hovership</title>
		<style>
			body { margin: 0; 
				background: #333; 
				color: #fff;
        font-family: monospace;
			}
			canvas { width: 100%; height: 100% }
			button { background: transparent; border:none; outline:none; cursor: pointer; font-family: monospace; font-size: 4em; color: #fff; opacity: 0.7;}
			#hud {position: absolute; top:0px; left:0px; width: 110px; }
			#go {left: 1em; display: none;}
			#go.show {left: 1em; display: block;}

			.slidecontainer {
        position: absolute;
        bottom: -360px;
       transform: rotate(-90deg);
       width: 300px; 
       height: 300px;
       z-index: 2;
         display: block; margin: 20px; padding:10px;
         margin: 0 8px;
}

#carrier {
  -webkit-appearance: none;
  width: 100%;
  height: 2px;
  background: rgba(100,100,100,0.2);
  outline: none;
  -webkit-transition: .2s;
  transition: opacity .2s;
}


#carrier::-webkit-slider-thumb {
  -webkit-appearance: none;
  appearance: none;
  width: 24px;
  height: 24px;
  border: 0;
  background: #666;
  opacity: 0.5;
  background-size: 70px;
  cursor: pointer;
}

#carrier::-moz-range-thumb {
  width: 24px;
  height: 24px;
  border: 0;
  background: #666;
  opacity: 0.5;
  background-size: 70px;
  cursor: pointer;
}

#carrier.on::-webkit-slider-thumb,
#carrier.on::-moz-range-thumb {opacity: 1;}

#carrier:hover,
#carrier:hover,
#carrier.on
 {background: red !important; opacity: 1 !important; cursor: pointer;}

button.on {color: #fff !important; background: red !important; opacity: 1;}
button:hover {background: red !important; opacity: 1 !important;}
button.on:hover {color: #fff !important;}

#space, #dirup, #dirdwn {background: transparent; outline: none; font-family: monospace; color: #fff; border:none; cursor: pointer; font-size: 1em; width: 108px; height: 24px; text-align: center; line-height: 20px; color: #fff; position: absolute; z-index: 1;
  top:60px; left:32px;}
button {background: rgba(255,255,255,0.1) !important;}
#dirup { top:32px; left: 204px; width: 24px; 
transform: rotate(-90deg); transform-origin: center; }
#dirdwn { left: 204px; width: 24px;
transform: rotate(90deg); transform-origin: center;  }
svg path {opacity: 0.15;}
#svgkeys {position: absolute;}
#keys {position: relative; bottom: 0; }
#keyboard {position: absolute; bottom: 94px; left: 4px;}

input {background: transparent; border:none; outline: none; color: #fff; font-family: monospace; font-size: 2em;}
#chkb, #chkg {position: absolute; right: 12px; top: 22px;  text-align: right; width: 40px; height: 40px; text-align: center; background: rgba(50,50,50,0.5); font-size: 2em; color: #fff; line-height: 40px;} 
#chkb.on, #chkg.on {background: #fff !important;}
#chkb {color: #fff; top: 70px;}
#chkg {color: red;}
		</style>
	</head>
	<body>

<div id="keyboard">

<div id="keys">
<button id="space" title="vertical/horizontal" onclick="verticalview()" >space</button>
<button id="dirup" title="go" onclick="incnum()">&gt;</button>
<button id="dirdwn" title="stop" onclick="decnum()" >&gt;</button>
</div>

<svg id="svgkeys" height="90" preserveAspectRatio="none" viewBox="0 0 260 90" width="260" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><defs><g id="a"><path d="m24 24v-24h-24v24z" fill="#903"/></g></defs><use transform="translate(4 60)" xlink:href="#a"/><use transform="translate(4 32)" xlink:href="#a"/><use transform="translate(4 4)" xlink:href="#a"/><use transform="translate(32 32)" xlink:href="#a"/><use transform="translate(32 4)" xlink:href="#a"/><use transform="translate(60 32)" xlink:href="#a"/><use transform="translate(60 4)" xlink:href="#a"/><use transform="translate(88 32)" xlink:href="#a"/><use transform="translate(88 4)" xlink:href="#a"/><use transform="translate(116 4)" xlink:href="#a"/><use transform="translate(144 60)" xlink:href="#a"/><use transform="translate(176 60)" xlink:href="#a"/><use transform="translate(232 60)" xlink:href="#a"/><g fill="#903"><path d="m26-26h-24v28h-28v24h52z" transform="translate(142 30)"/><path d="m54 12v-24h-108v24z" transform="translate(86 72)"/><path d="m12 12v-24h-24v24z" transform="translate(216 44)"/><path d="m12-12h-24v24h24z" transform="translate(216 72)"/></g></svg>

</div><!-- keyboard -->


    <span id="chkb" />w</span>
    <span id="chkg" />r</span>


<div id="hud">


<div class="slidecontainer">
  <input class="slider" id="carrier" type="range" value="0" min="0" max="0.0055" step="0.00001" oninput="handleCarrierChange(value)" />
</div>
</div>


<script src="../js/three.min.js"></script>
<script src="../js/GLTFLoader.js"></script>
<script src="../js/OrbitControls.min.js"></script>
<script src="../js/tween.js"></script>


<script>
// slider function
function handleCarrierChange(value) {
xval = value;
if (value>0) {stopwarp = false; 
  var ff = scene.getObjectByProperty( 'name', 'trail', false );
  ff.scale.x = 20*(value*200); } else {
    ff.scale.x = 0;
  }
}

var vertbtn = document.getElementById("space");
// vertical mode
function verticalview() {
  vertbtn.classList.toggle('on');
  if (vertbtn.classList != "on") {
plane.rotation.set(-Math.PI/2,0,0);
shadowground.visible = true;
shdw.visible = true;
horizontal = true;
new TWEEN.Tween( mothership.position).to( {x: mothership.position.x, y: 0, z: mothership.position.z}, 200 ).easing( TWEEN.Easing.Quadratic.EaseOut).start();
new TWEEN.Tween( gridHelper.rotation).to( {x: 0, y: 0, z: 0}, 200 ).easing( TWEEN.Easing.Quadratic.EaseOut).start();

  } else {
plane.rotation.set(0,Math.PI/2,0);
shadowground.visible = false;
shdw.visible = false;
horizontal = false;
cursor.position.x = 0;
new TWEEN.Tween( gridHelper.rotation).to( {x: 0, y: 0, z: Math.PI/2}, 200 ).easing( TWEEN.Easing.Quadratic.EaseOut).start();

  setTimeout(function() {
new TWEEN.Tween( hero.position).to( {x: 0, y: mothership.position.y, z: mothership.position.z}, 200 ).easing( TWEEN.Easing.Quadratic.EaseOut).start();

    }, 100);


}// else

}// vert mode

// variables
var bpoints = 0;
var gpoints = 0;

var collidableMeshList = [];

var stopwarp = true;
var horizontal = true;

var xval = 0;
var mixer;
var prevTime = Date.now();
var scene = new THREE.Scene();
var camera = new THREE.PerspectiveCamera( 75, window.innerWidth/window.innerHeight, 0.8, 1000 );
var renderer = new THREE.WebGLRenderer( { alpha: true, antialias: true } );
renderer.setSize( window.innerWidth, window.innerHeight );
renderer.shadowMap.enabled = true;
renderer.shadowMap.type = THREE.PCFShadowMap;
document.body.appendChild( renderer.domElement );

// scene settings
scene.position.set(0,0,0);
camera.position.x = 6;
camera.position.y = 1;
camera.position.z = 0;
camera.lookAt(0,0,0)

// lights
var light = new THREE.PointLight( 0xffffff, 1, 40 );
light.position.set( 10, 10, 10 );
scene.add( light );


var controls = new THREE.OrbitControls(camera, renderer.domElement);
controls.maxPolarAngle = Math.PI*0.46;
controls.enableDamping = true;
controls.dampingFactor = 0.4;
controls.maxDistance = 50;
controls.minDistance = 1;
controls.enablePan = false;

// grid
var size = 10;
var divisions = 1;
var gridHelper = new THREE.GridHelper( size, divisions );
// gridHelper.position.set( 0, 0.1, 0 );
scene.add(gridHelper)

// ambient
var light = new THREE.AmbientLight( 0x666666 );
light.intensity = 0.9;
scene.add( light );


// floor texture
var geometry = new THREE.PlaneBufferGeometry( 10, 10, 1 );

// var material = new THREE.MeshLambertMaterial( {color: 0x333333} );
// var ground = new THREE.Mesh( geometry, material );
// // ground.receiveShadow = true;
// ground.rotation.set (-Math.PI/2,0,0);
// scene.add( ground );


// shadowground
var txloader = new THREE.TextureLoader();
var groundtex = txloader.load( 'space.png' );
groundtex.magFilter = THREE.NearestFilter;
groundtex.minFilter = THREE.LinearMipMapLinearFilter;
groundtex.wrapS = groundtex.wrapT = THREE.RepeatWrapping;
var material = new THREE.MeshBasicMaterial( {color: 0xffffff
,transparent : true, opacity:0.4
,map:groundtex 
} );
var shadowground = new THREE.Mesh( geometry, material );
shadowground.position.set (0,0.05,0);
shadowground.rotation.set (-Math.PI/2,0,0);
scene.add( shadowground );



// resize
window.addEventListener( 'resize', onWindowResize, false );
function onWindowResize() {
camera.aspect = window.innerWidth / window.innerHeight;
camera.updateProjectionMatrix();
renderer.setSize( window.innerWidth, window.innerHeight );
}

// hero
hero = new THREE.Group();
scene.add( hero );

cursor = new THREE.Group();
scene.add(cursor);

mothership = new THREE.Group();
scene.add(mothership);

cube = new THREE.Group();
mothership.add(cube);


// hero
// let bgeometry = new THREE.PlaneGeometry( 1.5,  0.6, 1 );
let bgeometry = new THREE.BoxGeometry( 0.9, 0.6, 0.4 );
let mmaterial = new THREE.MeshLambertMaterial( { color: 0xcc0000, wireframe: true
 } );
let cubicbody = new THREE.Mesh( bgeometry, mmaterial );
cubicbody.position.set(0,0.5,0);
mothership.add( cubicbody );
cubicbody.visible = false;



// // car 3D model
var loader = new THREE.BufferGeometryLoader();

loader.load(
  'hcar.json',
  function ( geometry ) {
    var carmaterial = new THREE.MeshPhongMaterial( {
          color: 0xff0000
       } );


    car = new THREE.Mesh( geometry, carmaterial );
    car.name = "car"
    car.position.set(0,0.3, 0);
    car.rotation.set(0,Math.PI/2,0);
    car.scale.set(0.4,0.4,0.4);
    mothership.add( car );

},
  function ( xhr ) {
  },
  function ( xhr ) {
    console.log( 'An error happened' );
  }
  );// end load ship

// shadow 
let egeometry = new THREE.PlaneGeometry( 1.5, 0.6, 1 );
let ematerial = new THREE.MeshBasicMaterial( { 
  color: 0x000000,
   // transparent:true, opacity:0.2
    } );
let shdw = new THREE.Mesh( egeometry, ematerial );
shdw.position.set(0.05,0.2,0);
shdw.rotation.set(-Math.PI/2,0,0)
mothership.add(shdw);


// // trail
// var loader = new THREE.TextureLoader();
// loader.load( 'xgrad.png', function ( texture ) {
//   var trgeometry = new THREE.PlaneBufferGeometry( 0.1, 0.6, 1 );
//   trgeometry.applyMatrix( new THREE.Matrix4().makeTranslation(0.05, 0, 0) );

//   var trmaterial = new THREE.MeshBasicMaterial( {
//   color:0xff0000, map: texture, transparent: true, opacity: 0.7, side: THREE.DoubleSide
//    } );
//   var trail = new THREE.Mesh( trgeometry, trmaterial );
//   trail.name = "trail";
//   trail.position.set(0.2,0.45,0);
//   trail.rotation.set(-Math.PI/2,0,0)
//   mothership.add(trail);

// } );

// line
var geometry = new THREE.Geometry();
geometry.vertices.push(new THREE.Vector3(0.79, 0.45, -0.26));
geometry.vertices.push(new THREE.Vector3(0.79, 0.45, 0.26));
var material = new THREE.LineBasicMaterial({ color: 0xffffff });

var line = new THREE.Line(geometry, material);
line.scale.z = 0.000001;
mothership.add(line);


// sky night
var loader = new THREE.TextureLoader();
loader.load( 'wgrad.png', function ( texture ) {
  var skygeometry = new THREE.SphereGeometry(501, 32, 32)
  var skymaterial = new THREE.MeshBasicMaterial( { map: texture, side : THREE.BackSide
  ,transparent: true, opacity: 0.8
   } );
  var skyn = new THREE.Mesh( skygeometry, skymaterial );
  skyn.name = "skynight";
  scene.add(skyn);
} );


// end three objects

// update touch
  let updateTouchCoordinates = function(evt) {
  stopwarp = false; 
  mouse.x = ( evt.touches[0].pageX / window.innerWidth ) * 2 - 1;
  mouse.y = - ( evt.touches[0].pageY / window.innerHeight ) * 2 + 1;
  raycaster.setFromCamera( mouse, camera );
  let intersects = raycaster.intersectObject( plane );
  if (intersects.length > 0) { movehero(intersects[ 0 ].point.x, intersects[ 0 ].point.z); }
};


// update mouse
let updateMouseCoordinates = function(evt) {
  evt.preventDefault();
  mouse.x = ( evt.clientX / window.innerWidth ) * 2 - 1;
  mouse.y = - ( evt.clientY / window.innerHeight ) * 2 + 1;
  raycaster.setFromCamera( mouse, camera );
  let intersects = raycaster.intersectObject( plane );
  if (intersects.length > 0) { movehero(intersects[ 0 ].point.x, intersects[ 0 ].point.z, intersects[ 0 ].point.y); }



 
};


function movehero(x, y, z) {
    hero.position.x = x;
    hero.position.z = y;
    hero.position.y = z;
}


window.addEventListener( 'mousemove', updateMouseCoordinates, false );



//raycaster - ship
let shipray = new THREE.Raycaster();


//raycaster - mouse
let raycaster = new THREE.Raycaster();
let mouse = new THREE.Vector2();
let isDragging = false;

//plane geometry
let plgeometry = new THREE.PlaneBufferGeometry( 10, 10, 1 );

//plane material
let plmaterial = new THREE.MeshBasicMaterial( { 
// color:0x220000,
side: THREE.DoubleSide,
wireframe: true,
transparent:true,
opacity:0
} );

//raycast plane object3D
let plane = new THREE.Mesh( plgeometry, plmaterial );
plane.name = 'plane';
plane.rotation.set(-Math.PI/2,0,0);
plane.name = 'plane';

scene.add( plane );
// plane.visible = false;

// slow down to stop
function decnum() {
  document.getElementById('carrier').classList="on";
  document.getElementById('dirdwn').classList="on";
  collidableMeshList[0].visible = false;
  collidableMeshList[1].visible = false;
      // new TWEEN.Tween( mothership.position ).to( {x: mothership.position.x, y: 0, z: mothership.position.z}, 200 ).start();

  var sf = scene.getObjectByProperty( 'name', 'starfield', false );

for ( var i = 0; i < sf.children.length; i ++ ) {
new TWEEN.Tween( sf.children[i].scale ).to( {x: 1, y: 1, z: 0.01}, 400 ).onComplete(function() {
sf.visible = false;
}).start();
}//for
document.getElementById('carrier').value = 0;
xval = document.getElementById('carrier').value;


// var ff = scene.getObjectByProperty( 'name', 'trail', false );
// new TWEEN.Tween( ff.scale ).to( {x: 0.1, y: 1, z: 1}, 200 ).start();
new TWEEN.Tween( line.scale ).to( {x: 1, y: 1, z: 0.000001}, 200 ).start();
stopwarp = true;

setTimeout(function() {
  document.getElementById('dirdwn').classList="";
  document.getElementById('carrier').classList="";
}, 100);

};// decnum

// accelerate
function incnum() {
  document.getElementById('carrier').classList="on";
  document.getElementById('dirup').classList="on";
  collidableMeshList[0].visible = true;
  collidableMeshList[1].visible = true;
  // new TWEEN.Tween( mothership.position ).to( {x: mothership.position.x, y: 0.03, z: mothership.position.z}, 200 ).start();

  var sf = scene.getObjectByProperty( 'name', 'starfield', false );
  sf.visible = true;
  // console.log(scene)
  for ( var i = 0; i < sf.children.length; i ++ ) {
new TWEEN.Tween( sf.children[i].scale ).to( {x: 1, y: 1, z: 1}, 400 ).start();
}//for
document.getElementById('carrier').value = 0.0055;
xval = document.getElementById('carrier').value;

// var ff = scene.getObjectByProperty( 'name', 'trail', false );
// new TWEEN.Tween( ff.scale ).to( {x: 20, y: 1, z: 1}, 200 ).start();
new TWEEN.Tween( line.scale ).to( {x: 1, y: 1, z: 1}, 200 ).start();
stopwarp = false;

setTimeout(function() {
  document.getElementById('carrier').classList="";
  document.getElementById('dirup').classList="";
}, 100);

};//incnum

function jump() {
      console.log(mothership.position.y)
}


//keys
//esc
document.onkeydown = function(evt) {
    evt = evt || window.event;
    // console.log(evt)

if (evt.keyCode == 32) {
  evt.preventDefault();
  verticalview()
}

if (evt.keyCode == 38) {
  evt.preventDefault();
  incnum()
}

if (evt.keyCode == 40) {
  evt.preventDefault();
  decnum()
}
    
  };



// randomise
function randomFloat(a, b){
  var r =  (Math.random() * (b - a) + a);
  return r;
}

// make single star
function Star(material, x, y, size){
  this.size = size;

  this.obj = new THREE.Geometry();
  this.obj.vertices.push(new THREE.Vector3(0, 0, 0));
  this.obj.vertices.push(new THREE.Vector3(0, 0, -size));
  this.obj = new THREE.Line(this.obj, material);

  this.speed = randomFloat(1, 10);

  this.refresh = function(x, y){
    this.obj.position.z = randomFloat(0, -100);
    this.obj.position.x = x;
    this.obj.position.y = y;
  }
  this.refresh(x, y);
}

// make/update star field
function Starfield(size, width, height){
  this.stars = [];
  this.obj = new THREE.Group();
  this.obj.name = "starfield";
  this.obj.visible = false;
  this.obj.rotation.set(0,Math.PI/2,0);
  this.obj.position.set(0,0,0);
  this.size = size;
  this.width = width;
  this.height = height;
  this.material = new THREE.MeshBasicMaterial({color: 0xffffff});
  this.init = function(){
    for(var i = 0; i < this.size; i++){
      this.stars.push(new Star(this.material, randomFloat(-this.width, this.width), randomFloat(-this.width, this.width), randomFloat(0.1, 3)));
      this.obj.add(this.stars[i].obj);
    }
    scene.add(this.obj);
  }
  this.init();
  this.update = function(){
if (!stopwarp) {
    for(var i = 0; i < this.size; i++){
      if(this.stars[i].obj.position.z > 5){
        this.stars[i].refresh(randomFloat(-this.width, this.width), randomFloat(-this.width, this.width));
      }

      // this.stars[i].obj.position.z += this.stars[i].speed;
      this.stars[i].obj.position.z += xval*80;

          }

      }//if not stopwarp
  }// update
}



// collide objects
function walls() {
  var wallGeometry = new THREE.CubeGeometry( 0.3, 0.3, 0.3 );

  var blue = new THREE.MeshLambertMaterial( {color: 0xffffff} );
  var green = new THREE.MeshLambertMaterial( {color: 0xff0000} );

  var wall = new THREE.Mesh(wallGeometry, blue);
  wall.position.set(-3, 0.5, -3);
  wall.name = 'blue';
  scene.add(wall);
  collidableMeshList.push(wall);

  
  var wall2 = new THREE.Mesh(wallGeometry, green);
  wall2.position.set(3, 0.5, -3);
  wall2.name = 'green';
  scene.add(wall2);
  collidableMeshList.push(wall2);

  collidableMeshList[0].visible = false;
  collidableMeshList[1].visible = false;
}


// HIT function
function hit (v) {
if ( v.length > 0) {
car.material = new THREE.MeshPhongMaterial( {color: 0xffffff} );
var num = Math.floor(Math.random()*5) + 1;
num *= Math.floor(Math.random()*2) == 1 ? 1 : -1;
var num2 = Math.floor(Math.random()*5) + 1;
num2 *= Math.floor(Math.random()*2) == 1 ? 1 : -1;
v[0].object.position.x = num;
v[0].object.position.z = num2;
v[0].object.scale.y = 10;
if (v[0].object.name == 'blue') {bpoints+=1;
  document.getElementById('chkb').innerHTML=bpoints;
flash(document.getElementById('chkb'));
}
if (v[0].object.name == 'green') {gpoints+=1;
  flash(document.getElementById('chkg'));
  document.getElementById('chkg').innerHTML=gpoints;}
setTimeout(function() {
car.material = new THREE.MeshPhongMaterial( {color: 0xff0000} );
v[0].object.scale.y = 1;
}, 100);
}//if
}// fn hit


//flash helper f
function flash(argument) {
argument.classList = "on";
setTimeout(function() {
argument.classList = "";
}, 100);
}



// animate loop
var animate = function () {
requestAnimationFrame( animate );
renderer.render(scene, camera);
controls.update();
TWEEN.update();
stars.update();

// if (!stopwarp) {

groundtex.offset.x -= xval*3;
// position lerp
mothership.position.x += (hero.position.x - cursor.position.x)*0.1;
mothership.position.z += (hero.position.z - cursor.position.z)*0.2;
// 
cursor.position.x = mothership.position.x;
cursor.position.z = mothership.position.z;
//
mothership.rotation.x = (hero.position.z - mothership.position.z)*0.2;// bank
mothership.rotation.z = -(hero.position.x - mothership.position.x)*0.05;// pitch
mothership.rotation.y = (hero.position.z - mothership.position.z)*0.2;// turn

// vertical controls
if (!horizontal) { 
mothership.position.y += (hero.position.y - cursor.position.y)*0.5;
cursor.position.y = mothership.position.y;
mothership.rotation.z = -(hero.position.y - mothership.position.y)*0.5;// bank
groundtex.offset.x =0;
groundtex.offset.y -= xval*3;
}


  for (var vertexIndex = 0; vertexIndex < cubicbody.geometry.vertices.length; vertexIndex++)
  {   
    var localVertex = cubicbody.geometry.vertices[vertexIndex].clone();
    var globalVertex = localVertex.applyMatrix4( cubicbody.matrix );
    var directionVector = globalVertex.sub( cubicbody.position );

    var vray = new THREE.Raycaster( mothership.position, directionVector.normalize() );
    var collisionResults = vray.intersectObjects( collidableMeshList );
    if ( collisionResults.length > 0 && collidableMeshList.distance < directionVector.length() ) 
      console.log('hit');
    hit(collisionResults)
  }

    // set collectables speed/pos
collidableMeshList[0].position.x += xval*22;
if (collidableMeshList[0].position.x > 5) {
    collidableMeshList[0].position.x = -5;
}

collidableMeshList[1].position.x += xval*12;
if (collidableMeshList[1].position.x > 5) {
  collidableMeshList[1].position.x = -5;
}


// car.position.y += ( 0.2 - car.position.y ) * 0.01;

//
  //blink/flicker
// if ( Math.random() > 0.9 && !stopwarp) { car.position.y = 
// (hero.position.y - cursor.position.y)*0.1; } else { 
// }
// }//if warp is true
}; //render loop

    walls();
  setTimeout(function () {
// stars
  stars = new Starfield(10, 9, 9);
    var sf = scene.getObjectByProperty( 'name', 'starfield', false );
for ( var i = 0; i < sf.children.length; i ++ ) { sf.children[i].scale.z = 0.1; }

animate();

  }, 200);

		</script>
	</body>
</html>